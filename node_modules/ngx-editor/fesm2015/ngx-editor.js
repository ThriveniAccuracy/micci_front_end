import { __decorate, __param } from 'tslib';
import { ɵɵdefineInjectable, Injectable, Optional, ɵɵinject, ViewChild, Component, forwardRef, ViewEncapsulation, InjectionToken, NgModule } from '@angular/core';
import { NG_VALUE_ACCESSOR } from '@angular/forms';
import { Plugin, PluginKey, EditorState } from 'prosemirror-state';
import { DecorationSet, Decoration, EditorView } from 'prosemirror-view';
import { setBlockType, toggleMark } from 'prosemirror-commands';
import { Schema } from 'prosemirror-model';
import { nodes as nodes$1, marks } from 'prosemirror-schema-basic';
import { listItem as listItem$1, orderedList as orderedList$2, bulletList as bulletList$2, liftListItem, wrapInList } from 'prosemirror-schema-list';
import { findSelectedNodeOfType, findParentNode } from 'prosemirror-utils';

const listGroup = 'block';
const listItem = Object.assign({}, listItem$1, { content: 'paragraph block*' });
const orderedList = Object.assign({}, orderedList$2, { content: 'list_item+', group: listGroup });
const bulletList = Object.assign({}, bulletList$2, { content: 'list_item+', group: listGroup });
const nodes = Object.assign({}, nodes$1, {
    list_item: listItem,
    ordered_list: orderedList,
    bullet_list: bulletList
});
const schema = new Schema({
    marks: marks,
    nodes
});

const isNodeActive = (state, type, attrs = {}) => {
    const { $from, to } = state.selection;
    const predicate = (n) => n.type === type;
    const node = findSelectedNodeOfType(type)(state.selection) || findParentNode(predicate)(state.selection);
    if (!Object.entries(attrs).length || !node) {
        return !!node;
    }
    // check if heading is active
    return to <= $from.end() && $from.parent.hasMarkup(type, attrs);
};

const isMarkActive = (state, type) => {
    const { from, $from, to, empty } = state.selection;
    if (empty) {
        return !!type.isInSet(state.storedMarks || $from.marks());
    }
    else {
        return state.doc.rangeHasMark(from, to, type);
    }
};

const toggleBlockType = (type, toggleType, attrs = {}) => {
    return (state, dispatch) => {
        const isActive = isNodeActive(state, type, attrs);
        if (isActive) {
            return setBlockType(toggleType)(state, dispatch);
        }
        return setBlockType(type, attrs)(state, dispatch);
    };
};

const toggleList = (type, itemType) => {
    return (state, dispatch) => {
        const isActive = isNodeActive(state, type);
        if (isActive) {
            return liftListItem(itemType)(state, dispatch);
        }
        return wrapInList(type)(state, dispatch);
    };
};

/* tslint:disable */
var bold = `
  <path d="M15.6 10.79c.97-.67 1.65-1.77 1.65-2.79 0-2.26-1.75-4-4-4H7v14h7.04c2.09 0 3.71-1.7 3.71-3.79 0-1.52-.86-2.82-2.15-3.42zM10 6.5h3c.83 0 1.5.67 1.5 1.5s-.67 1.5-1.5 1.5h-3v-3zm3.5 9H10v-3h3.5c.83 0 1.5.67 1.5 1.5s-.67 1.5-1.5 1.5z" />
  <path d="M0 0h24v24H0z" fill="none" />
`;

var italic = `
  <path d="M0 0h24v24H0z" fill="none" />
  <path d="M10 4v3h2.21l-3.42 8H6v3h8v-3h-2.21l3.42-8H18V4z" />
`;

var code = `
<path d="M0 0h24v24H0V0z" fill="none"/>
<path d="M9.4 16.6L4.8 12l4.6-4.6L8 6l-6 6 6 6 1.4-1.4zm5.2 0l4.6-4.6-4.6-4.6L16 6l6 6-6 6-1.4-1.4z"/>
`;

var orderedList$1 = `
<path d="M2 17h2v.5H3v1h1v.5H2v1h3v-4H2v1zm1-9h1V4H2v1h1v3zm-1 3h1.8L2 13.1v.9h3v-1H3.2L5 10.9V10H2v1zm5-6v2h14V5H7zm0 14h14v-2H7v2zm0-6h14v-2H7v2z"/>
<path d="M0 0h24v24H0z" fill="none"/>
`;

var bulletList$1 = `
<path d="M0 0h24v24H0V0z" fill="none"/>
<path d="M4 10.5c-.83 0-1.5.67-1.5 1.5s.67 1.5 1.5 1.5 1.5-.67 1.5-1.5-.67-1.5-1.5-1.5zm0-6c-.83 0-1.5.67-1.5 1.5S3.17 7.5 4 7.5 5.5 6.83 5.5 6 4.83 4.5 4 4.5zm0 12c-.83 0-1.5.68-1.5 1.5s.68 1.5 1.5 1.5 1.5-.68 1.5-1.5-.67-1.5-1.5-1.5zM7 19h14v-2H7v2zm0-6h14v-2H7v2zm0-8v2h14V5H7z"/>
`;

var arrowDropDown = `
<path d="M7 10l5 5 5-5z"/><path d="M0 0h24v24H0z" fill="none"/>
`;

// Icons source: https://material.io/
const DEFAULT_ICON_HEIGHT = 20;
const DEFAULT_ICON_WIDTH = 20;
const icons = {
    bold,
    italic,
    code,
    ordered_list: orderedList$1,
    bullet_list: bulletList$1,
    arrow_drop_down: arrowDropDown
};
// Helper function to create menu icons
function getIconSvg(name, width = DEFAULT_ICON_WIDTH, height = DEFAULT_ICON_HEIGHT) {
    const path = icons[name] || '<path></path>';
    return `
  <svg
    xmlns="http://www.w3.org/2000/svg"
    viewBox="0 0 24 24"
    fill="black"
    height=${height}
    width=${width}
  >
    ${path}
  </svg>
  `;
}

const flatDeep = (arr, d = 1) => {
    return d > 0
        ? arr.reduce((acc, val) => acc.concat(Array.isArray(val) ? flatDeep(val, d - 1) : val), [])
        : arr.slice();
};
const ɵ0 = flatDeep;

const menuItemsMeta = {
    bold: {
        key: 'strong',
        i18nKey: 'bold',
        icon: 'bold',
        type: 'mark',
    },
    italic: {
        key: 'em',
        i18nKey: 'italics',
        icon: 'italic',
        type: 'mark',
    },
    code: {
        key: 'code',
        i18nKey: 'code',
        icon: 'code',
        type: 'mark',
    },
    ordered_list: {
        key: 'ordered_list',
        i18nKey: 'ordered_list',
        icon: 'ordered_list',
        type: 'node',
    },
    bullet_list: {
        key: 'bullet_list',
        i18nKey: 'bullet_list',
        icon: 'bullet_list',
        type: 'node',
    },
    h1: {
        key: 'heading',
        i18nKey: 'heading',
        attrs: {
            level: 1,
        },
        type: 'node'
    },
    h2: {
        key: 'heading',
        i18nKey: 'heading',
        attrs: {
            level: 2,
        },
        type: 'node'
    },
    h3: {
        key: 'heading',
        i18nKey: 'heading',
        attrs: {
            level: 3,
        },
        type: 'node'
    },
    h4: {
        key: 'heading',
        i18nKey: 'heading',
        attrs: {
            level: 4,
        },
        type: 'node'
    },
    h5: {
        key: 'heading',
        i18nKey: 'heading',
        attrs: {
            level: 5,
        },
        type: 'node'
    },
    h6: {
        key: 'heading',
        i18nKey: 'heading',
        attrs: {
            level: 6,
        },
        type: 'node'
    }
};

const MENU_ITEM_CLASSNAME = 'NgxEditor-MenuItem';
const DROPDOWN_ITEMS = new Map();
DROPDOWN_ITEMS.set('heading', ['h1', 'h2', 'h3', 'h4', 'h5', 'h6']);
const isListItem = (type) => {
    return (type === schema.nodes.list_item ||
        type === schema.nodes.ordered_list ||
        type === schema.nodes.bullet_list);
};
const ɵ0$1 = isListItem;
class DropDownView {
    constructor(dropdownGroup, dropdownFields, editorView, options) {
        this.updates = [];
        this.dropdownGroup = dropdownGroup;
        this.dropdownFields = dropdownFields;
        this.editorView = editorView;
        this.options = options;
    }
    getWrapperDom() {
        let isDropdownOpen = false;
        const dropdownWrapper = document.createElement('div');
        const labels = this.options.labels;
        dropdownWrapper.classList.add(MENU_ITEM_CLASSNAME);
        dropdownWrapper.classList.add(`${MENU_ITEM_CLASSNAME}__Dropdown-Wrapper`);
        // create dropdown content
        const dropdown = document.createElement('div');
        dropdown.classList.add(`${MENU_ITEM_CLASSNAME}__Dropdown`);
        const dropdownText = document.createElement('div');
        dropdownText.classList.add(`${MENU_ITEM_CLASSNAME}__Dropdown-Text`);
        dropdownText.textContent = labels[this.dropdownGroup];
        const dropdownIcon = document.createElement('div');
        dropdownIcon.classList.add(`${MENU_ITEM_CLASSNAME}__Dropdown-Icon`);
        dropdownIcon.innerHTML = getIconSvg('arrow_drop_down');
        dropdown.appendChild(dropdownText);
        dropdown.appendChild(dropdownIcon);
        const dropdownOpenClassName = `${MENU_ITEM_CLASSNAME}__Dropdown-Wrapper-Open`;
        const mouseDownHandler = (e) => {
            e.preventDefault();
            if (!dropdownWrapper.contains(e.target)) {
                closeDropdown();
            }
        };
        const openDropdown = () => {
            dropdownWrapper.classList.add(dropdownOpenClassName);
            isDropdownOpen = true;
            window.addEventListener('mousedown', mouseDownHandler);
        };
        const closeDropdown = () => {
            dropdownWrapper.classList.remove(dropdownOpenClassName);
            isDropdownOpen = false;
            window.removeEventListener('mousedown', mouseDownHandler);
        };
        dropdown.addEventListener('click', (e) => {
            e.preventDefault();
            if (!isDropdownOpen) {
                openDropdown();
            }
            else {
                closeDropdown();
            }
        });
        // create dropdown list
        const dropdownList = document.createElement('div');
        dropdownList.classList.add(`${MENU_ITEM_CLASSNAME}__Dropdown-Menu`);
        this.dropdownFields.forEach(dropdownItem => {
            const menuItem = menuItemsMeta[dropdownItem];
            let text = labels[menuItem.key];
            if (menuItem.key === 'heading') {
                text += ` ${menuItem.attrs.level}`;
            }
            const spec = {
                classNames: [
                    `${MENU_ITEM_CLASSNAME}__Dropdown-Item`
                ],
                textContent: text,
                attrs: {
                    title: text
                }
            };
            const menuItemView = new MenuItemView(menuItem, this.editorView, spec);
            const { update, dom } = menuItemView.render();
            // remove open class once clicked on dropdown value
            dom.addEventListener('click', (e) => {
                e.preventDefault();
                closeDropdown();
            });
            // wrapper to execute when update is called
            const dropUpdate = (state) => {
                update(state);
                const selectedClass = `${MENU_ITEM_CLASSNAME}__Dropdown-Wrapper-Selected`;
                // update the dropdown content heading when a class is selected
                const activeEl = dropdownList.getElementsByClassName(`${MENU_ITEM_CLASSNAME}__Active`);
                if (activeEl.length) {
                    const el = activeEl[0];
                    dropdownText.textContent = el.textContent;
                    dropdownWrapper.classList.add(selectedClass);
                }
                else {
                    // restore default value
                    dropdownText.textContent = labels[this.dropdownGroup];
                    dropdownWrapper.classList.remove(selectedClass);
                }
            };
            dropdownList.appendChild(dom);
            this.updates.push(dropUpdate);
        });
        dropdownWrapper.appendChild(dropdown);
        dropdownWrapper.appendChild(dropdownList);
        return dropdownWrapper;
    }
    render() {
        this.dom = this.getWrapperDom();
        return {
            dom: this.dom,
            updates: this.updates
        };
    }
}
class MenuItemView {
    constructor(menuItem, editorView, spec) {
        this.menuItem = menuItem;
        this.editorView = editorView;
        this.spec = spec;
    }
    render() {
        const dom = this.dom = this.getDom();
        this.setupCommandListeners();
        const update = (state) => {
            const menuItem = this.menuItem;
            let isActive = false;
            if (menuItem.type === 'mark') {
                const type = schema.marks[menuItem.key];
                isActive = isMarkActive(state, type);
            }
            if (menuItem.type === 'node') {
                const type = schema.nodes[menuItem.key];
                isActive = isNodeActive(state, type, menuItem.attrs);
            }
            dom.classList.toggle(`${MENU_ITEM_CLASSNAME}__Active`, isActive);
        };
        return {
            dom,
            update
        };
    }
    getDom() {
        const div = document.createElement('div');
        if (this.spec.classNames) {
            this.spec.classNames.forEach(className => {
                div.classList.add(className);
            });
        }
        if (this.spec.attrs) {
            Object.entries(this.spec.attrs).forEach(obj => {
                div.setAttribute(obj[0], obj[1]);
            });
        }
        if (this.spec.innerHTML) {
            div.innerHTML = this.spec.innerHTML;
        }
        if (this.spec.textContent) {
            div.innerHTML = this.spec.textContent;
        }
        return div;
    }
    setupCommandListeners() {
        this.dom.addEventListener('mousedown', (e) => {
            e.preventDefault();
            // don't execute if not left click
            if (e.buttons !== 1) {
                return;
            }
            if (this.menuItem.type === 'mark') {
                const command = toggleMark(schema.marks[this.menuItem.key]);
                command(this.editorView.state, this.editorView.dispatch);
                return;
            }
            if (this.menuItem.type === 'node') {
                const type = schema.nodes[this.menuItem.key];
                if (isListItem(type)) {
                    const command = toggleList(type, schema.nodes.list_item);
                    command(this.editorView.state, this.editorView.dispatch);
                    return;
                }
                if (type === schema.nodes.heading) {
                    const command = toggleBlockType(type, schema.nodes.paragraph, { level: this.menuItem.attrs.level });
                    command(this.editorView.state, this.editorView.dispatch);
                    return;
                }
            }
        });
    }
}
const getSeperatorDom = () => {
    const div = document.createElement('div');
    div.className = `${MENU_ITEM_CLASSNAME}__Seperator`;
    return div;
};
const ɵ1 = getSeperatorDom;
const renderMenu = (options, editorView, menuDom) => {
    const updates = [];
    const toolbar = options.toolbar;
    toolbar.forEach((group, toolbarIndex) => {
        const isLastMenuGroup = toolbar.length - 1 === toolbarIndex;
        group.forEach((toolbarItem, menuIndex) => {
            const isLastMenuItem = group.length - 1 === menuIndex;
            // render dropdown
            if (typeof toolbarItem === 'object') {
                Object.keys(toolbarItem).forEach((dropdownGroup) => {
                    if (DROPDOWN_ITEMS.has(dropdownGroup)) {
                        const dropdown = toolbarItem[dropdownGroup];
                        const dropdownView = new DropDownView(dropdownGroup, dropdown, editorView, options);
                        const rendered = dropdownView.render();
                        updates.push(rendered.updates);
                        menuDom.appendChild(rendered.dom);
                    }
                    else {
                        console.warn('Unkown dropdown group:', dropdownGroup);
                    }
                });
            }
            // render Icons
            if (typeof toolbarItem === 'string') {
                const menuItem = menuItemsMeta[toolbarItem];
                const labels = options.labels;
                if (menuItem) {
                    const spec = {
                        classNames: [
                            MENU_ITEM_CLASSNAME,
                            `${MENU_ITEM_CLASSNAME}__Icon`,
                            `${MENU_ITEM_CLASSNAME}__${menuItem.key}`
                        ],
                        innerHTML: getIconSvg(menuItem.icon),
                        attrs: {
                            title: labels[menuItem.i18nKey]
                        }
                    };
                    const menuItemView = new MenuItemView(menuItem, editorView, spec);
                    const { update, dom } = menuItemView.render();
                    menuDom.appendChild(dom);
                    updates.push(update);
                }
            }
            if (isLastMenuItem && !isLastMenuGroup) {
                const seperatorDom = getSeperatorDom();
                menuDom.appendChild(seperatorDom);
            }
        });
    });
    const combinedUpdates = flatDeep(updates, Infinity);
    return {
        update(state) {
            combinedUpdates.forEach((update) => {
                update(state);
            });
        }
    };
};

class MenuBarView {
    constructor(editorView, options) {
        // const menu = getMenu(toolbar);
        this.view = editorView;
        this.options = options;
        this.render();
        this.update();
    }
    render() {
        const menuDom = document.createElement('div');
        menuDom.className = 'NgxEditor-MenuBar';
        const { update } = renderMenu(this.options, this.view, menuDom);
        this.updateMenuItems = update;
        this.view.dom.parentNode.insertBefore(menuDom, this.view.dom);
    }
    update() {
        this.updateMenuItems(this.view.state);
    }
}

const DEFAULT_TOOLBAR = [
    ['bold', 'italic'],
    ['code'],
    ['ordered_list', 'bullet_list'],
    [{ heading: ['h1', 'h2', 'h3', 'h4', 'h5', 'h6'] }]
];
const DEFAULT_LABELS = {
    bold: 'Bold',
    italics: 'Italics',
    code: 'Code',
    ordered_list: 'Ordered List',
    bullet_list: 'Bullet List',
    heading: 'Heading'
};
const DEFAULT_OPTIONS = {
    toolbar: DEFAULT_TOOLBAR,
    labels: DEFAULT_LABELS
};
function menuPlugin(options) {
    return new Plugin({
        key: new PluginKey('menu'),
        view(editorView) {
            return new MenuBarView(editorView, options);
        },
    });
}
const menu = (options = DEFAULT_OPTIONS) => {
    return menuPlugin(options);
};
const ɵ0$2 = menu;

const DEFAULT_PLACEHOLDER = 'Type Here...';
function placeholderPlugin(text = DEFAULT_PLACEHOLDER) {
    return new Plugin({
        key: new PluginKey('placeholder'),
        props: {
            decorations(state) {
                const doc = state.doc;
                if (doc.childCount === 1 && doc.firstChild.isTextblock && doc.firstChild.content.size === 0) {
                    const placeHolderEl = document.createElement('span');
                    placeHolderEl.classList.add('NgxEditor-Placeholder');
                    placeHolderEl.textContent = text;
                    return DecorationSet.create(doc, [Decoration.widget(1, placeHolderEl)]);
                }
                return DecorationSet.empty;
            }
        }
    });
}

let NgxEditorServiceConfig = class NgxEditorServiceConfig {
    constructor() {
        this.plugins = [
            menu(),
            placeholderPlugin()
        ];
    }
};
NgxEditorServiceConfig.ɵprov = ɵɵdefineInjectable({ factory: function NgxEditorServiceConfig_Factory() { return new NgxEditorServiceConfig(); }, token: NgxEditorServiceConfig, providedIn: "root" });
NgxEditorServiceConfig = __decorate([
    Injectable({
        providedIn: 'root'
    })
], NgxEditorServiceConfig);
let NgxEditorService = class NgxEditorService {
    constructor(config) {
        this.config = config;
    }
};
NgxEditorService.ctorParameters = () => [
    { type: NgxEditorServiceConfig, decorators: [{ type: Optional }] }
];
NgxEditorService.ɵprov = ɵɵdefineInjectable({ factory: function NgxEditorService_Factory() { return new NgxEditorService(ɵɵinject(NgxEditorServiceConfig, 8)); }, token: NgxEditorService, providedIn: "root" });
NgxEditorService = __decorate([
    Injectable({
        providedIn: 'root'
    }),
    __param(0, Optional())
], NgxEditorService);
function provideMyServiceOptions(config) {
    return (config);
}

var NgxEditorComponent_1;
let NgxEditorComponent = NgxEditorComponent_1 = class NgxEditorComponent {
    constructor(ngxEditorService) {
        this.config = ngxEditorService.config;
    }
    writeValue(value) {
        if (!value) {
            return;
        }
        this.updateContent(value);
    }
    registerOnChange(fn) {
        this.onChange = fn;
    }
    registerOnTouched() { }
    parseDoc(contentJson) {
        return schema.nodeFromJSON(contentJson);
    }
    updateContent(value) {
        try {
            const doc = this.parseDoc(value);
            const state = this.view.state;
            const tr = state.tr;
            tr.replaceWith(0, state.doc.content.size, doc);
            this.view.dispatch(tr);
        }
        catch (err) {
            console.error('Unable to update document.', err);
        }
    }
    handleTransactions(tr) {
        const { state } = this.view.state.applyTransaction(tr);
        this.view.updateState(state);
        if (tr.docChanged) {
            const json = state.doc.toJSON();
            this.onChange(json);
        }
    }
    createEditor() {
        this.view = new EditorView(this.ngxEditor.nativeElement, {
            state: EditorState.create({
                schema,
                plugins: this.config.plugins,
            }),
            dispatchTransaction: this.handleTransactions.bind(this),
            attributes: {
                class: 'NgxEditor-Content'
            },
        });
    }
    ngOnInit() {
        this.createEditor();
    }
    ngOnDestroy() {
        this.view.destroy();
    }
};
NgxEditorComponent.ctorParameters = () => [
    { type: NgxEditorService }
];
__decorate([
    ViewChild('ngxEditor', { static: true })
], NgxEditorComponent.prototype, "ngxEditor", void 0);
NgxEditorComponent = NgxEditorComponent_1 = __decorate([
    Component({
        selector: 'ngx-editor',
        template: "<div class=\"NgxEditor-Wrapper\" #ngxEditor></div>\n",
        providers: [{
                provide: NG_VALUE_ACCESSOR,
                useExisting: forwardRef(() => NgxEditorComponent_1),
                multi: true
            }],
        encapsulation: ViewEncapsulation.None,
        styles: [".ProseMirror{outline:0}.NgxEditor-Wrapper{background:padding-box #fff;color:#000;border-radius:4px;border:2px solid rgba(0,0,0,.2)}.NgxEditor-MenuBar{display:flex;padding:.2rem;border-bottom:1px solid #ddd}.NgxEditor-MenuBar .NgxEditor-MenuItem{display:flex;align-items:center;justify-content:center}.NgxEditor-MenuBar .NgxEditor-MenuItem:hover{cursor:pointer;background-color:#f1f1f1}.NgxEditor-MenuBar .NgxEditor-MenuItem.NgxEditor-MenuItem__Icon{height:30px;width:30px;transition:.3s ease-in-out;border-radius:2px;margin-right:2px}.NgxEditor-MenuBar .NgxEditor-MenuItem.NgxEditor-MenuItem__Icon.NgxEditor-MenuItem__Active{background-color:#e8f0fe}.NgxEditor-MenuBar .NgxEditor-MenuItem.NgxEditor-MenuItem__Icon.NgxEditor-MenuItem__Active svg{fill:#1a73e8}.NgxEditor-MenuBar .NgxEditor-MenuItem.NgxEditor-MenuItem__Dropdown-Wrapper{position:relative;max-width:100px;width:100%;justify-content:start}.NgxEditor-MenuBar .NgxEditor-MenuItem.NgxEditor-MenuItem__Dropdown-Wrapper .NgxEditor-MenuItem__Dropdown{display:flex;align-items:center;width:100%}.NgxEditor-MenuBar .NgxEditor-MenuItem.NgxEditor-MenuItem__Dropdown-Wrapper .NgxEditor-MenuItem__Dropdown .NgxEditor-MenuItem__Dropdown-Text{margin-left:5px}.NgxEditor-MenuBar .NgxEditor-MenuItem.NgxEditor-MenuItem__Dropdown-Wrapper .NgxEditor-MenuItem__Dropdown .NgxEditor-MenuItem__Dropdown-Icon{margin-left:auto;position:relative;top:2px}.NgxEditor-MenuBar .NgxEditor-MenuItem.NgxEditor-MenuItem__Dropdown-Wrapper .NgxEditor-MenuItem__Dropdown-Menu{position:absolute;left:0;top:30px;box-shadow:rgba(60,64,67,.15) 0 2px 6px 2px;border-radius:4px;background-color:#fff;display:none}.NgxEditor-MenuBar .NgxEditor-MenuItem.NgxEditor-MenuItem__Dropdown-Wrapper .NgxEditor-MenuItem__Dropdown-Menu .NgxEditor-MenuItem__Dropdown-Item{cursor:pointer;padding:.5rem 1rem;white-space:nowrap}.NgxEditor-MenuBar .NgxEditor-MenuItem.NgxEditor-MenuItem__Dropdown-Wrapper .NgxEditor-MenuItem__Dropdown-Menu .NgxEditor-MenuItem__Dropdown-Item.NgxEditor-MenuItem__active,.NgxEditor-MenuBar .NgxEditor-MenuItem.NgxEditor-MenuItem__Dropdown-Wrapper .NgxEditor-MenuItem__Dropdown-Menu .NgxEditor-MenuItem__Dropdown-Item:hover{background-color:#f1f1f1}.NgxEditor-MenuBar .NgxEditor-MenuItem.NgxEditor-MenuItem__Dropdown-Wrapper.NgxEditor-MenuItem__Dropdown-Wrapper-Open,.NgxEditor-MenuBar .NgxEditor-MenuItem.NgxEditor-MenuItem__Dropdown-Wrapper.NgxEditor-MenuItem__Dropdown-Wrapper-Selected{background-color:#e8f0fe;color:#1a73e8}.NgxEditor-MenuBar .NgxEditor-MenuItem.NgxEditor-MenuItem__Dropdown-Wrapper.NgxEditor-MenuItem__Dropdown-Wrapper-Open .NgxEditor-MenuItem__Dropdown-Icon svg{fill:#1a73e8}.NgxEditor-MenuBar .NgxEditor-MenuItem.NgxEditor-MenuItem__Dropdown-Wrapper.NgxEditor-MenuItem__Dropdown-Wrapper-Open .NgxEditor-MenuItem__Dropdown-Menu{display:block;color:initial}.NgxEditor-MenuBar .NgxEditor-MenuItem__Seperator{border-left:1px solid #ccc;margin:0 5px}.NgxEditor-Content{padding:.5rem;white-space:pre-wrap}.NgxEditor-Content p{margin:0 0 .7rem}.NgxEditor-Placeholder{color:#6c757d;opacity:1}"]
    })
], NgxEditorComponent);

var NgxEditorModule_1;
const NGX_EDITOR_CONFIG_TOKEN = new InjectionToken('NgxEditorConfig');
let NgxEditorModule = NgxEditorModule_1 = class NgxEditorModule {
    static forRoot(config) {
        return {
            ngModule: NgxEditorModule_1,
            providers: [
                {
                    provide: NGX_EDITOR_CONFIG_TOKEN,
                    useValue: config
                },
                {
                    provide: NgxEditorServiceConfig,
                    useFactory: provideMyServiceOptions,
                    deps: [NGX_EDITOR_CONFIG_TOKEN]
                }
            ]
        };
    }
};
NgxEditorModule = NgxEditorModule_1 = __decorate([
    NgModule({
        declarations: [NgxEditorComponent],
        exports: [NgxEditorComponent],
    })
], NgxEditorModule);

/*
 * Public API Surface of ngx-editor
 */

/**
 * Generated bundle index. Do not edit.
 */

export { NgxEditorComponent, NgxEditorModule, isMarkActive, isNodeActive, menu, placeholderPlugin as placeholder, schema, toggleBlockType, toggleList, NgxEditorServiceConfig as ɵa, NgxEditorService as ɵb, provideMyServiceOptions as ɵc };
//# sourceMappingURL=ngx-editor.js.map
